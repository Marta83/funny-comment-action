'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var AggregateError = _interopDefault(require('aggregate-error'));
var crypto = require('crypto');
var buffer = require('buffer');
var debug = require('debug');

const webhookNames = ["*", "check_run", "check_run.completed", "check_run.created", "check_run.requested_action", "check_run.rerequested", "check_suite", "check_suite.completed", "check_suite.requested", "check_suite.rerequested", "commit_comment", "commit_comment.created", "content_reference", "content_reference.created", "create", "delete", "deploy_key", "deploy_key.created", "deploy_key.deleted", "deployment", "deployment.created", "deployment_status", "deployment_status.created", "error", "fork", "github_app_authorization", "github_app_authorization.revoked", "gollum", "installation", "installation.created", "installation.deleted", "installation.new_permissions_accepted", "installation.suspend", "installation.unsuspend", "installation_repositories", "installation_repositories.added", "installation_repositories.removed", "issue_comment", "issue_comment.created", "issue_comment.deleted", "issue_comment.edited", "issues", "issues.assigned", "issues.closed", "issues.deleted", "issues.demilestoned", "issues.edited", "issues.labeled", "issues.locked", "issues.milestoned", "issues.opened", "issues.pinned", "issues.reopened", "issues.transferred", "issues.unassigned", "issues.unlabeled", "issues.unlocked", "issues.unpinned", "label", "label.created", "label.deleted", "label.edited", "marketplace_purchase", "marketplace_purchase.cancelled", "marketplace_purchase.changed", "marketplace_purchase.pending_change", "marketplace_purchase.pending_change_cancelled", "marketplace_purchase.purchased", "member", "member.added", "member.edited", "member.removed", "membership", "membership.added", "membership.removed", "meta", "meta.deleted", "milestone", "milestone.closed", "milestone.created", "milestone.deleted", "milestone.edited", "milestone.opened", "org_block", "org_block.blocked", "org_block.unblocked", "organization", "organization.deleted", "organization.member_added", "organization.member_invited", "organization.member_removed", "organization.renamed", "package", "package.published", "package.updated", "page_build", "ping", "project", "project.closed", "project.created", "project.deleted", "project.edited", "project.reopened", "project_card", "project_card.converted", "project_card.created", "project_card.deleted", "project_card.edited", "project_card.moved", "project_column", "project_column.created", "project_column.deleted", "project_column.edited", "project_column.moved", "public", "pull_request", "pull_request.assigned", "pull_request.closed", "pull_request.edited", "pull_request.labeled", "pull_request.locked", "pull_request.merged", "pull_request.opened", "pull_request.ready_for_review", "pull_request.reopened", "pull_request.review_request_removed", "pull_request.review_requested", "pull_request.synchronize", "pull_request.unassigned", "pull_request.unlabeled", "pull_request.unlocked", "pull_request_review", "pull_request_review.dismissed", "pull_request_review.edited", "pull_request_review.submitted", "pull_request_review_comment", "pull_request_review_comment.created", "pull_request_review_comment.deleted", "pull_request_review_comment.edited", "push", "release", "release.created", "release.deleted", "release.edited", "release.prereleased", "release.published", "release.released", "release.unpublished", "repository", "repository.archived", "repository.created", "repository.deleted", "repository.edited", "repository.privatized", "repository.publicized", "repository.renamed", "repository.transferred", "repository.unarchived", "repository_dispatch", "repository_dispatch.on-demand-test", "repository_import", "repository_vulnerability_alert", "repository_vulnerability_alert.create", "repository_vulnerability_alert.dismiss", "repository_vulnerability_alert.resolve", "security_advisory", "security_advisory.performed", "security_advisory.published", "security_advisory.updated", "sponsorship", "sponsorship.cancelled", "sponsorship.created", "sponsorship.edited", "sponsorship.pending_cancellation", "sponsorship.pending_tier_change", "sponsorship.tier_changed", "star", "star.created", "star.deleted", "status", "team", "team.added_to_repository", "team.created", "team.deleted", "team.edited", "team.removed_from_repository", "team_add", "watch", "watch.started", "workflow_dispatch", "workflow_run", "workflow_run.action"];

function receiverOn(state, webhookNameOrNames, handler) {
  if (Array.isArray(webhookNameOrNames)) {
    webhookNameOrNames.forEach(webhookName => receiverOn(state, webhookName, handler));
    return;
  }

  if (webhookNames.indexOf(webhookNameOrNames) === -1) {
    console.warn(`"${webhookNameOrNames}" is not a known webhook name (https://developer.github.com/v3/activity/events/types/)`);
  }

  if (!state.hooks[webhookNameOrNames]) {
    state.hooks[webhookNameOrNames] = [];
  }

  state.hooks[webhookNameOrNames].push(handler);
}

// Errors thrown or rejected Promises in "error" event handlers are not handled
// as they are in the webhook event handlers. If errors occur, we log a
// "Fatal: Error occured" message to stdout
function wrapErrorHandler(handler, error) {
  let returnValue;

  try {
    returnValue = handler(error);
  } catch (error) {
    console.log('FATAL: Error occured in "error" event handler');
    console.log(error);
  }

  if (returnValue && returnValue.catch) {
    returnValue.catch(error => {
      console.log('FATAL: Error occured in "error" event handler');
      console.log(error);
    });
  }
}

function getHooks(state, eventPayloadAction, eventName) {
  const hooks = [state.hooks[`${eventName}.${eventPayloadAction}`]];

  if (Array.isArray(eventName)) {
    eventName.forEach(name => hooks.push(state.hooks[name]));
  } else {
    hooks.push(state.hooks[eventName]);
  }

  hooks.push(state.hooks["*"]); // @ts-ignore

  return [].concat(...hooks.filter(Boolean));
} // main handler function


function receiverHandle(state, event) {
  const errorHandlers = state.hooks.error || [];

  if (event instanceof Error) {
    const error = Object.assign(new AggregateError([event]), {
      event,
      errors: [event]
    });
    errorHandlers.forEach(handler => wrapErrorHandler(handler, error));
    return Promise.reject(error);
  }

  if (!event || !event.name) {
    throw new AggregateError(["Event name not passed"]);
  }

  if (!event.payload) {
    throw new AggregateError(["Event payload not passed"]);
  } // flatten arrays of event listeners and remove undefined values


  const hooks = getHooks(state, event.payload.action, event.name);

  if (hooks.length === 0) {
    return Promise.resolve();
  }

  const errors = [];
  const promises = hooks.map(handler => {
    let promise = Promise.resolve(event);

    if (state.transform) {
      promise = promise.then(state.transform);
    }

    return promise.then(event => {
      return handler(event);
    }).catch(error => errors.push(Object.assign(error, {
      event
    })));
  });
  return Promise.all(promises).then(() => {
    if (errors.length === 0) {
      return;
    }

    const error = new AggregateError(errors);
    Object.assign(error, {
      event,
      errors
    });
    errorHandlers.forEach(handler => wrapErrorHandler(handler, error));
    throw error;
  });
}

function removeListener(state, webhookNameOrNames, handler) {
  if (Array.isArray(webhookNameOrNames)) {
    webhookNameOrNames.forEach(webhookName => removeListener(state, webhookName, handler));
    return;
  }

  if (!state.hooks[webhookNameOrNames]) {
    return;
  } // remove last hook that has been added, that way
  // it behaves the same as removeListener


  for (let i = state.hooks[webhookNameOrNames].length - 1; i >= 0; i--) {
    if (state.hooks[webhookNameOrNames][i] === handler) {
      state.hooks[webhookNameOrNames].splice(i, 1);
      return;
    }
  }
}

function createEventHandler(options) {
  const state = {
    hooks: {}
  };

  if (options && options.transform) {
    state.transform = options.transform;
  }

  return {
    on: receiverOn.bind(null, state),
    removeListener: removeListener.bind(null, state),
    receive: receiverHandle.bind(null, state)
  };
}

function isntWebhook(request, options) {
  // GitHub sends all events as POST requests
  if (request.method !== "POST") {
    return true;
  } // We must match the configured path to allow custom POST routes which include
  // the webhook route. For example if the webhook route is / then it would be
  // impossible to define a `POST /my/custom/app` route as the `POST /`.


  if (typeof request.url !== "string" || request.url.split("?")[0] !== options.path) {
    return true;
  }

  return false;
}

const WEBHOOK_HEADERS = ["x-github-event", "x-hub-signature", "x-github-delivery"]; // https://developer.github.com/webhooks/#delivery-headers

function getMissingHeaders(request) {
  return WEBHOOK_HEADERS.filter(header => !(header in request.headers));
}

function getPayload(request) {
  // If request.body already exists we can stop here
  // See https://github.com/octokit/webhooks.js/pull/23
  // @ts-ignore
  if (request.body) return Promise.resolve(request.body);
  return new Promise((resolve, reject) => {
    let data = "";
    request.on("error", error => reject(new AggregateError([error])));
    request.on("data", chunk => data += chunk);
    request.on("end", () => {
      try {
        resolve(JSON.parse(data));
      } catch (error) {
        error.message = "Invalid JSON";
        error.status = 400;
        reject(new AggregateError([error]));
      }
    });
  });
}

function sign(secret, payload) {
  if (!secret || !payload) {
    throw new TypeError("secret & payload required");
  }

  payload = typeof payload === "string" ? payload : toNormalizedJsonString(payload);
  return "sha1=" + crypto.createHmac("sha1", secret).update(payload).digest("hex");
}

function toNormalizedJsonString(payload) {
  return JSON.stringify(payload).replace(/[^\\]\\u[\da-f]{4}/g, s => {
    return s.substr(0, 3) + s.substr(3).toUpperCase();
  });
}

function verify(secret, eventPayload, signature) {
  if (!secret || !eventPayload || !signature) {
    throw new TypeError("secret, eventPayload & signature required");
  }

  const signatureBuffer = buffer.Buffer.from(signature);
  const verificationBuffer = buffer.Buffer.from(sign(secret, eventPayload));

  if (signatureBuffer.length !== verificationBuffer.length) {
    return false;
  }

  return crypto.timingSafeEqual(signatureBuffer, verificationBuffer);
}

function verifyAndReceive(state, event) {
  const matchesSignature = verify(state.secret, event.payload, event.signature);

  if (!matchesSignature) {
    const error = new Error("signature does not match event payload and secret");
    return state.eventHandler.receive(Object.assign(error, {
      event,
      status: 400
    }));
  }

  return state.eventHandler.receive({
    id: event.id,
    name: event.name,
    payload: event.payload
  });
}

const debugWebhooks = debug.debug("webhooks:receiver");
function middleware(state, request, response, next) {
  if (isntWebhook(request, {
    path: state.path
  })) {
    // the next callback is set when used as an express middleware. That allows
    // it to define custom routes like /my/custom/page while the webhooks are
    // expected to be sent to the / root path. Otherwise the root path would
    // match all requests and would make it impossible to define custom rooutes
    if (next) {
      next();
      return;
    }

    debugWebhooks(`ignored: ${request.method} ${request.url}`);
    response.statusCode = 404;
    response.end("Not found");
    return;
  }

  const missingHeaders = getMissingHeaders(request).join(", ");

  if (missingHeaders) {
    const error = new Error(`Required headers missing: ${missingHeaders}`);
    return state.eventHandler.receive(error).catch(() => {
      response.statusCode = 400;
      response.end(error.message);
    });
  }

  const eventName = request.headers["x-github-event"];
  const signature = request.headers["x-hub-signature"];
  const id = request.headers["x-github-delivery"];
  debugWebhooks(`${eventName} event received (id: ${id})`);
  return getPayload(request).then(payload => {
    return verifyAndReceive(state, {
      id: id,
      name: eventName,
      payload,
      signature
    });
  }).then(() => {
    response.end("ok\n");
  }).catch(error => {
    const statusCode = Array.from(error)[0].status;
    response.statusCode = statusCode || 500;
    response.end(error.toString());
  });
}

function createMiddleware(options) {
  if (!options || !options.secret) {
    throw new Error("options.secret required");
  }

  const state = {
    eventHandler: createEventHandler(options),
    path: options.path || "/",
    secret: options.secret,
    hooks: {}
  };
  const api = middleware.bind(null, state);
  api.on = state.eventHandler.on;
  api.removeListener = state.eventHandler.removeListener;
  return api;
}

class Webhooks {
  constructor(options) {
    if (!options || !options.secret) {
      throw new Error("options.secret required");
    }

    const state = {
      eventHandler: createEventHandler(options),
      path: options.path || "/",
      secret: options.secret,
      hooks: {}
    };
    this.sign = sign.bind(null, options.secret);
    this.verify = verify.bind(null, options.secret);
    this.on = state.eventHandler.on;
    this.removeListener = state.eventHandler.removeListener;
    this.receive = state.eventHandler.receive;
    this.middleware = middleware.bind(null, state);
    this.verifyAndReceive = verifyAndReceive.bind(null, state);
  }

}

const createWebhooksApi = Webhooks.prototype.constructor;

exports.Webhooks = Webhooks;
exports.createEventHandler = createEventHandler;
exports.createMiddleware = createMiddleware;
exports.createWebhooksApi = createWebhooksApi;
exports.sign = sign;
exports.verify = verify;
//# sourceMappingURL=index.js.map
